/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

const explicitExtensionRe = /\.[mc]?js$/;
const explicitJsExtensionRe = /\.js$/;

/*
 * NodeJS resolver that enables the interop with the current Bazel setup.
 *
 * The loader will attempt resolution by replacing explicit extension with
 * their ESM variants. It also tries completing import specifiers in case no
 * extension of explicit file is specified.
 *
 * There are a few cases:
 *
 *   * Relative imports without an extension. This happens because our
 *     source files cannot use explicit `.mjs` extensions yet.
 *   * Relative imports with an explicit extension to `.js`. This may
 *     be generated by TypeScript as we have `.ts` source files.
 *   * Local module imports. In NPM, extensions are not needed as the
 *     `package.json` `exports` help resolving. In Bazel when dealing with
 *     1st-party packages- `package.json` is not consulted in resolution.
 *        1. The NPM artifacts differ from the source compilation output.
 *        2. It results in additional churn, having to put `package.json` into `bin`.
 */
export async function resolve(specifier, context, nextResolve) {
  // Actual resolution is the actual specifier. This is where errors
  // should not be silenced as it's the actual user-specifier.
  let resolveError = null;
  try {
    return await nextResolve(specifier, context);
  } catch (e) {
    resolveError = e;
  }

  const interopAttempts = [];
  if (explicitJsExtensionRe.test(specifier)) {
    interopAttempts.push(specifier.replace(explicitJsExtensionRe, '.mjs'));
  }

  if (!explicitExtensionRe.test(specifier)) {
    interopAttempts.push(`${specifier}.mjs`);
    interopAttempts.push(`${specifier}/index.mjs`);
  }

  for (const attempt of interopAttempts) {
    try {
      return await nextResolve(attempt, context);
    } catch {}
  }

  // Rethrow the existing resolution error.
  throw resolveError;
}
